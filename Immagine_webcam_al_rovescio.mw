Alcuni produttori hanno pensato bene di montare al contrario la webcam in alcuni modelli di portatili per motivi di spazio.
Il problema è di facile soluzione quando il modulo di gestione della cam prevede l'opzione "flip" che capovolge l'immagine, ma se il modulo di gestione è uvcvideo, allora siete nei guai, perchè questo modulo non prevede il rovesciamento dell'immagine.
Fortunatamente potete applicare la seguente procedura , testata e verificata su Fedora 14 kernel 2.6.35.
__TOC__
==Cominciamo==
installate come prima cosa i pacchetti sviluppo:
 # yum groupinstall "strumenti di sviluppo"
 # yum install kernel-devel[/code]
scaricate il pacchetto[http://linuxtv.org/hg/v4l-dvb/archive/tip.tar.gz uvc-video] e scompattatelo in $HOME/Scaricati.
==Modifichiamo il sorgente==
 $ gedit $HOME/Scaricati/v4l-dvb-abd3aac6644e/linux/drivers/media/video/uvc/uvc_video.c
sosituite questa sezione:
<pre>static void uvc_video_decode_data(struct uvc_streaming *stream,
        struct uvc_buffer *buf, const __u8 *data, int len)
{
    struct uvc_video_queue *queue = &stream->queue;
    unsigned int maxlen, nbytes;
    void *mem;

    if (len <= 0)
        return;

    /* Copy the video data to the buffer. */
    maxlen = buf->buf.length - buf->buf.bytesused;
    mem = queue->mem + buf->buf.m.offset + buf->buf.bytesused;
    nbytes = min((unsigned int)len, maxlen);
    memcpy(mem, data, nbytes);
    buf->buf.bytesused += nbytes;

    /* Complete the current frame if the buffer size was exceeded. */
    if (len > maxlen) {
        uvc_trace(UVC_TRACE_FRAME, "Frame complete (overflow).\n");
        buf->state = UVC_BUF_STATE_READY;
    }
}</pre>
con questa sezione:
<pre>static void uvc_video_decode_data(struct uvc_streaming *stream,
      struct uvc_buffer *buf, const __u8 *data, int len)
{
   struct uvc_video_queue *queue = &stream->queue;
   unsigned int maxlen, nbytes, row_size, to_be_copied, shift_right;
   void *mem;

   if (len <= 0)
      return;

   /* Copy the video data to the buffer. */
   maxlen = buf->buf.length - buf->buf.bytesused;
   mem = queue->mem + buf->buf.m.offset + buf->buf.bytesused;
   nbytes = min((unsigned int)len, maxlen);
   row_size = stream->cur_frame->wWidth *
                 stream->format->bpp / 8;
   /* Each loop "nbytes" is decremented of the number of bytes just copied.
    * So are there any other bytes to be copied?
    */
   while (nbytes > 0) {
      /* As the rows of modified frames have to be fulfilled from
       * bottom-left to top-right, each cycle tries to complete a
       * single row.
       * In this cycle where is it needed to start to store bytes
       * within the selected row? From the beginning or shifted
       * right? Because other bytes could have been already stored in
       * that row without completing it, so it could be needed a right
       * shift.
       */
      shift_right = buf->buf.bytesused % row_size;
      /* In this cycle how many byte can we copy in the selected row?
       */
      if (nbytes > row_size - shift_right)
         to_be_copied = row_size - shift_right ;
      else
         to_be_copied = nbytes;
      /* "queue->mem + buf->buf.m.offset" is the base-address where to
       * start to store the current frame. This address refers to a
       * preallocated area (just for a sigle frame) taking part in a
       * circular buffer, where to store a fixed number of sequent
       * frames.
       */
      memcpy(queue->mem + buf->buf.m.offset
             /* Go to the end of this frame. */
             + row_size * stream->cur_frame->wHeight
             /* Go back for the number of bytes corrisponding to the
              * already fully completed rows.
         */
             - (buf->buf.bytesused - shift_right)
             /* Go back at the starting point of the upper row. */
             - row_size
             /* Shift right on this row if it is needed. */
             + shift_right,
             data,
             to_be_copied );
      /* Update "data", "byteused" and "nbytes" values. */
      data += to_be_copied;
      buf->buf.bytesused += to_be_copied ;
      nbytes -= to_be_copied;
   }
   /* Complete the current frame if the buffer size was exceeded. */
   if (len > maxlen) {
      uvc_trace(UVC_TRACE_FRAME, "Frame complete (overflow).\n");
      buf->state = UVC_BUF_STATE_DONE;
   }
}</pre>
salvate, chiudete.
==Compiliamo ed installiamo il modulo==
sempre da utente procediamo con la compilazione:
 $ cd $HOME/Scaricati/v4l-dvb-abd3aac6644e/
 $ make
poi da root :
 $ su
 password_di_root
 # modprobe -r uvcvideo
 # mv /lib/modules/`uname -r`/kernel/drivers/media/video/uvc/uvcvideo.ko /lib/modules/`uname -r`/kernel/drivers/media/video/uvc/uvcvideo.old
 # cp $HOME/Scaricati/v4l-dvb-abd3aac6644e/v4l/uvcvideo.ko /lib/modules/`uname -r`/kernel/drivers/media/video/uvc/uvcvideo.ko
 # depmod -a
==Terminiamo==
date un reboot e godetevi la vostra cam.

ringrazio l'utente Fedorista per aver testato la procedura.

[[Categoria:Configurazione]]
